---
title: 'CSS-Layouts: Display Grid, Flexbox und Co. erkl√§rt'
description: 'Du bist mit den Grundlagen von CSS vertraut und m√∂chtest jetzt deine Website layouten? Dieses Tutorial verschafft dir einen √úberblick √ºber die Techniken.'
isDraft: false
pubDate: 2024-05-06T16:50:00+00:00
author: david-maciejewski
cover:
  path: '/src/images/tutorials/website-wireframes.png'
  alt: 'Mann blickt auf seinen Schreibtisch voller Skizzen'
  caption: 'Der Kreative bist du, CSS hilft dir bei der Umsetzung.'
tags: ['css']
---

import Figure from '@components/Figure.astro'
import Button from '@components/Button.astro'

import SnippetFlow from '@snippets/layout-in-css/snippet-flow.astro'
import SnippetFlebox from '@snippets/layout-in-css/snippet-flexbox.astro'
import SnippetGridLayout from '@snippets/layout-in-css/snippet-grid-layout.astro'
import SnippetGridFlex from '@snippets/layout-in-css/snippet-grid-flex.astro'
import SnippetFloat from '@snippets/layout-in-css/snippet-float.astro'
import SnippetPosition from '@snippets/layout-in-css/snippet-position.astro'
import SnippetColumns from '@snippets/layout-in-css/snippet-columns.astro'

> **Hinweis:** Bevor du dich mit den Layouttechniken vertraut machst, solltest du bereits ein Grundverst√§ndnis von HTML und CSS haben. Lies dazu bitte die Tutorials [Einstieg in HTML](/tutorials/einstieg-in-html) und [Einstieg in CSS](/tutorials/einstieg-in-css) und komme hier dann wieder zur√ºck.

## Flow Layout (normaler Fluss)

Das CSS Flow Layout beschreibt, wie HTML-Elemente im normalen Fluss auf einer Webseite ohne dein Zutun angeordnet werden. Die Reihenfolge der Elemente im Quellcode bestimmt dabei die Reihenfolge, in der sie auf der Seite erscheinen. In HTML unterscheidet man zwischen Block-Elementen und Inline-Elementen.

Block-Elemente
: Block-Elemente erscheinen untereinander und haben eine Breite von 100 Prozent. Dazu geh√∂ren: u.&thinsp;a. `<div>`, `<p>`, `<h1>`, `<ul>`, `<li>`.

Inline-Elemente
: Im Gegensatz zu Block-Elementen erscheinen Inline-Elemente wie einzelne W√∂rter in einem Absatz nebeneinander und sind nur so breit wie ihr Inhalt. Dazu geh√∂ren: u.&thinsp;a. `<span>`, `<a>`, `<img>`, `<strong>`, `<em>`.

Schauen wir uns einmal beide Elemente im Vergleich an:

<Figure caption="Block-Elemente werden untereinander, Inline-Elemente nebeneinander angeordnet.">
  <SnippetFlow title="Block-Elemente" />
</Figure>

Auch die [Leserichtung](http://localhost:4321/tutorials/logische-eigenschaften-in-css) bestimmt, wie Inline-Elemente auf der Seite angeordnet werden. W√§hrend im Deutschen und Englischen Elemente wie die Leserichtung von links nach rechts angeordnet werden, ist das in anderen Sprachen wie Arabisch oder Hebr√§isch genau umgekehrt.

## Display-Eigenschaft

Jedes HTML-Element hat die Eigenschaft `display`, die festlegt, wie das Element auf der Seite angezeigt wird. Block-Elemente haben dabei im normalen Fluss den Wert `block`, Inline-Elemente den Wert `inline`. Das kannst du aber auch √§ndern, um das Layout deiner Seite zu beeinflussen.

Ein Link innerhalb eines Absatzes wird standardm√§√üig inline angezeigt, da das `<a>`-Element mit `display: inline` vorbelegt ist. M√∂chtest du mit einem Link eine ganze Gruppe von HTML-Elementen verlinken, solltest du den Anzeigewert auf `display: block` √§ndern, damit dieser wie ein Block-Element behandelt wird und in eine neue Zeile umbrucht. Denn bei Inline-Elementen kannst du die H√∂he und Breite nicht ver√§ndern, da diese wird durch ihren Inhalt bestimmt wird.

<Figure caption="Block-Elemente werden untereinander, Inline-Elemente nebeneinander angeordnet.">
  ```html
  <p>
    Lies bitte das Tutorial <a href="/tutorials/einstieg-in-html">Einstieg in HTML</a>.
  </p>

  <a href="/tutorials/einstieg-in-html" class="card">
    <h3>Einstieg in HTML</h3>
    <img src="/images/tutorials/html-logo.png" alt="HTML-Logo" />
  </a>
  ```
  ```css
  /* Alle Links mit einem href-Attribut */
  :any-link { display: inline; text-decoration: underline; }

  /* Nur unsere Karte */
  .card { display: block; text-decoration: none; }
  ```
</Figure>

Die `display`-Eigenschaft verf√ºgt auch √ºber weitere Werte, die das Layout beeinflussen. Die wichtigsten sind `display: flex` und `display: grid`, mit denen du komplexe Layouts erstellen kannst.

## Flexbox

Flexbox ist eine eindimensionale Layouttechnik, Elemente horizontal in einer Zeile oder vertikal in einer Spalte anzuordnen. Um in einem Header beispielsweise das Logo links und die Navigation rechts anzuordnen, setze beim Header die `display`-Eigenschaft auf `flex`.

<Figure caption="Mit Flebox k√∂nnen wir auch Block-Elemente leicht nebeneinander platzieren.">
  ```html
  <header class="site-header">
    <div>Logo</div>
    <nav>Navigation</nav>
  </header>
  ```
  ```css
  .site-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  ```
  <SnippetFlebox />
</Figure>

Zur dargestellten Verteilung der Elemente innerhalb des Headers ben√∂tigst du allerdings noch weitere Eigenschaften: `justify-content` ordnet die Elemente auf der Hauptachse an, `align-items` auf der Querachse.

### Haupt- und Querachse

In Flexbox gibt es zwei Achsen. Die Hauptachse verl√§uft in unserer Leserichtung horizontal, die Querachse steht dazu im rechten Winkel, also vertikal. Du kannst die Achsen mit der `flex-direction`-Eigenschaft √§ndern, wenn du zum Beispiel m√∂chtest, dass die Elemente auf einem Smartphone vertikal und auf gr√∂√üeren Displays horizontal angeordnet werden sollen. Mit `flex-direction: row` wird die Hauptachse horizontal und mit `flex-direction: column` vertikal ausgerichtet.

Josh Comeau hat ein [interaktiven Leitfaden](https://www.joshwcomeau.com/css/interactive-guide-to-flexbox/#introduction-to-flexbox-1) zu Flexbox erstellt, das dir die wichtigsten Eigenschaften und deren Anwendung n√§herbringt.

## Grid Layout

W√§hrend Flexbox f√ºr ein eindimensionales Layout ausgelegt ist, ist das Grid Layout f√ºr zwei Dimensionen ausgelegt, also f√ºr die Anordnung von Elementen in Zeilen und Spalten. Die M√∂glichkeiten von CSS Grid sind vielf√§ltig, aber gleichzeitig auch sehr komplex.

√Ñhnlich wie bei Flexbox aktivieren wir das Grid-Layout beim dar√ºberliegenden Element mit der Eigenschaft `display: grid`. Schauen wir uns ein relativ einfaches Beispiel an:

<Figure caption="Dank CSS Grid wird aus den HTML-Elementen ein Layout erstellt.">
  ```html
  <div class="grid">
    <div>#1</div>
    <div>#2</div>
    <div>#3</div>
    <div>#4</div>
    <div class="wide">#5</div>
  </div>
  ```
  ```css
  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 100px;
    gap: 0.6em;

    .wide {
      grid-column: span 2;
    }
  }
  ```
  <SnippetGridLayout/>
</Figure>

Das Beispiel enh√§lt ein Raster mit drei Spalten (`grid-template-columns`) und zwei Zeilen (`grid-template-rows`). Mit der Anzahl der Werte teilen wir dem Browser jeweils mit, wie viele Spalten bzw. Zeilen wir haben wollen.

Die Einheit der Werte bestimmt dabei dann dessen Breite oder H√∂he. Die Ma√üeinheit `fr` steht f√ºr ‚ÄûFractional Unit‚Äú (Bruchteilseinheit). Mit `1fr` teilst du den verf√ºgbaren Platz in gleich gro√üe Teile auf. Bei drei Spalten erh√§lt jede Spalte also ein Drittel (33,333&thinsp;%) des verf√ºgbaren Platzes.

Mit absoluten Werten wie `100px` oder relativen Werten wie `10em` kannst du die Gr√∂√üe der Spalten oder Zeilen auch direkt vorbelegen. Das ist besonders dann sinnvoll, wenn du eine feste Breite oder H√∂he ben√∂tigst, die sich nicht an den verf√ºgbaren Platz anpassen soll.

Das `gap`-Attribut sorgt f√ºr einen Abstand zwischen den Elementen. Mit `grid-column: span 2` wird das f√ºnfte Element √ºber zwei Spalten dargestellt.

### Flexible Layouts ohne Breakpoints

Mit CSS Grid k√∂nnen wir auch flexible Layouts erstellen, bei denen wir dem Browser √ºberlassen, wie viele Spalten er nebeneinander darstellen soll. Das ist besonders n√ºtzlich f√ºr responsive Layouts, bei denen wir keine festen Breakpoints[^1] definieren m√∂chten.

In dem folgenden Beispiel wollen wir Spalten mit einer Mindestbreite von 200 Pixeln und einer maximalen Breite von einer Fractional Unit (`fr`) darstellen. Das bedeutet, dass die Spalten mindestens 200 Pixel breit sind, sich aber auch an den verf√ºgbaren Platz anpassen k√∂nnen. Mit `auto-fit` teilen wir dem Browser mit, dass er so viele Spalten nebeneinander darstellen soll, wie es der verf√ºgbare Platz zul√§sst. Spiele mit dem Schieberegler, um die Mindestbreite der Spalten zu ver√§ndern.

<Figure caption="Passe mit dem Schieberegler die Mindestbreite der Elemente an.">
  ```html
  <div class="grid">
    <div>#1</div>
    <div>#2</div>
    <div>#3</div>
    <div>#4</div>
    <div>#5</div>
    <div>#6</div>
  </div>
  ```
  ```css
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 0.6em;
  }
  ```
  <SnippetGridFlex/>
</Figure>

Auch f√ºr CSS Grid hat Josh Comeau einen [interaktiven Leitfaden](https://www.joshwcomeau.com/css/interactive-guide-to-grid/) erstellt, der dir die wichtigsten Eigenschaften und deren Anwendung n√§herbringt.

## Floats

Ein gefloatetes Element √§ndert das Verhalten vom Element und den umliegenden Elementen im normalem Fluss. Das Element wird dabei nach links oder rechts verschoben und aus dem normalen Fluss entfernt, sodass der umliegende Inhalt um das Element herumflie√üt.

In dem folgenden Beispiel wollen wir zwei Abs√§tze um ein Bild herumflie√üen lassen. Das ist mit der Eigenschaft `float` auf dem Bild m√∂glich.

<Figure caption="Alle folgenden Elemente nach dem Bild werden nun um das Bild herum angeordnet.">
  ```html
  <div>
    <div class="image">Image</div>
    <p>Lorem ipsum ‚Ä¶</p>
    <p>Lorem ipsum ‚Ä¶</p>
  </div>
  ```
  ```css
  .image {
    float: left;
    block-size: 100px;
    aspect-ratio: 1 / 1;
    margin-inline-end: 1rem;
    border-radius: 50%;
  }
  ```
  <SnippetFloat />
</Figure>

Wenn du ein Element mit `float` verschiebst, kann das zu unerwarteten Ergebnissen f√ºhren, insbesondere wenn die H√∂he des gefloateten Elements nicht explizit festgelegt ist. Der Browser kann das Elternelement[^2] eines gefloatete Elements nicht automatisch anpassen. Dies f√ºhrt dazu, dass das Elternelement ‚Äûkollabiert‚Äú und keine sichtbare H√∂he hat.

Die Eigenschaft `display: flow-root;` am Elternelement behebt dieses Problem, indem es einen neuen Kontext f√ºr die Blockformatierung erstellt. Unabh√§ngig davon wird die `float`-Eigenschaft heute nur noch selten verwendet, da wir mit [Flexbox](#flexbox) und [Grid](#grid-layout) f√ºr die meisten Anforderungen geeignetere Alternativen haben.

## Positionierung

Mit der Positionierung durch die Eigenschaft `position` kannst du einzelne Elemente von der Stelle, an der sie sonst im normalen Fluss platziert w√§ren, an eine andere Stelle platzieren. √Ñhnlich wie einen Klebezettel, den du aufnimmst und dort hinklebst, wo du ihn haben m√∂chtest. Folgende Werte sind dabei m√∂glich:

`position: static`
: Das Element wird im normalen Fluss angezeigt (Standard).

`position: relative`
: Das Element wird relativ zu seiner urspr√ºnglichen Position verschoben.

`position: absolute`
: Das Element wird vollst√§ndig aus dem normalen Fluss herausgel√∂st, so als bef√§nde es sich auf einer seperaten Ebene. Nachfolgende Elemente rutschen nach oben.

`position: fixed`
: Das Element wird relativ zum Viewport positioniert und bleibt immer an der gleichen Stelle, auch wenn du die Seite scrollst. Auf dieser Seite siehst du das anhand des Headers.

`position: sticky`
: Das Element bleibt beim scrollen der Seite innerhalb seines √ºbergeordneten Elements platziert, bis dessen unterer Rand erreicht ist. Bei dem Inhaltsverzeichis auf dieser Seite habe ich das so umgesetzt.

<Figure caption="Das Element wird absolut oben rechts positioniert.">
  ```html
  <div class="product">
    ‚Ä¶
    <div class="new">Neu eingetroffen</div>
  </div>
  ```
  ```css
  .product {
    position: relative; /* Setzt den Nullpunkt zur√ºck */
  }

  .new {
    position: absolute;
    block-start: 0; /* Y-Koordinate */
    inline-end: 0;  /* X-Koordinate */
    z-index: 2; /* Ebene */
  }
  ```
  <SnippetPosition/>
</Figure>

Die Angabe von `position: absolute` bewirkt zun√§chst erst einmal nichts, also f√ºgen wir noch die Eigenschaften `block-start` und `inline-start` hinzu. Diese bestimmen die Position des Elements auf der Y- und X-Achse.

`block-start` und `inline-end` sind die [logische Eigenschaften](/tutorials/logische-eigenschaften-in-css) von `top` und `right`. Mit ihnen ist der relative Abstand des Elements zum √ºbergeordneten Element gemeint. Der Nullpunkt f√ºr die Koordinaten ist dabei die linke obere Ecke des √ºbergeordneten Elements, oder in diesem Fall die rechte obere Ecke, da wir hier `inline-end` statt `inline-start` oder `left` benutzt haben.

Ohne die Angabe von `position: relative` beim √ºbergeordneten Element w√ºrde das absolut positionierte Element relativ zum Viewport[^3] positioniert werden. Das ist in den meisten F√§llen nicht das gew√ºnschte Verhalten. Diese Eigenschaft setzt quasi den Nullpunkt f√ºr die Koordinaten zur√ºck, bzw. bekommt das √ºbergeordnete Element sein eigenes Koordinatensystem.

## Mehrspalten-Layout

Das CSS-Modul f√ºr mehrspaltiges Layout bietet eine einfache M√∂glichkeit, Inhalte in Spalten anzuordnen, √§hnlich wie der Text in einer Zeitung.

> **Vorsicht:** Vermeide Spalten, wenn der Inhalt nur lesbar w√§re, wenn daf√ºr rauf- und runtergescrollen m√ºsste. Das w√§re eine schlechte Usability.

Um einen Block in einen mehrspaltigen Container zu verwandeln, kannst du die Eigenschaften `column-count` oder `column-width` verwenden. Mit `column-count` teilst du dem Browser mit, wie viele Spalten du haben m√∂chtest. Mit `column-width` teilst du dem Browser mit, dass er den Container mit so vielen Spalten wie m√∂glich einer bestimmten Breite f√ºllen soll. In diesem Beispiel haben wir die Breite auf 20 Zeichen (`ch`) festgelegt.


<Figure caption="Das Element wird absolut oben rechts positioniert.">
  ```html
  <div class="columns">
    <h2>Mehrspaltiges Layout</h2>
    <p>Lorem ipsum ‚Ä¶</p>
    <p>Lorem ipsum ‚Ä¶</p>
    <p>Lorem ipsum ‚Ä¶</p>
  </div>
  ```
  ```css
  .columns {
    column-width: 20ch;
  }
  ```
  <SnippetColumns />
</Figure>

## Meine Empfehlung f√ºr dein Layout

Gibt es das pefekte Layout f√ºr alle Einsatzbereiche? Nein, das w√§re zu einfach. Tats√§chlich f√ºhren mehrere Wege nach Rom, wie ich immer gern sage. Die eine L√∂sung kann funktonieren, die andere vielleicht nur mit etwas mehr Aufwand. Grunds√§tzlich w√ºrde ich dir aber folgendes gern mit auf dem Weg geben:

- Vertraue auf den **normalen Fluss**, wenn es geht. Das ist die einfachste und zuverl√§ssigste Methode, um insbesondere auch bei mobilen Endger√§ten einen linearen Lesefluss zu gew√§hrleisten.
- **Flexbox** ist super, wenn du einfach nur zwei oder mehr Elemente neben- oder untereinander platzieren m√∂chtest. Das ist besonders f√ºr Navigationen oder f√ºr eine Gruppierung von Elementen geeignet.
- **Grid Layout** kannst du verwenden, wenn du ein Elemente in die Mitte eines anderen platzieren m√∂chtest, kannst damit aber auch (sehr) komplexe Layouts erstellen. Da die Lernkurve sehr steil ist, ist das nichts, das du wie Flexbox mal eben in einer Zeile schreiben kannst.
- Am Ende bleibt dann noch die **Positionierung**, mit der du recht sp√§rlich umgehen solltest, um ein Chaos zu vermeiden. Die Positionierung ist allerdings unabdingbar, wenn du Elemente irgendwohin ‚Äûkleben‚Äú m√∂chtest, wie die Navigation oder ein Inhaltsverzeichnis, wie auf dieser Seite.

Ich w√ºnsche dir mit diesem Rundumschlag auf jeden Fall viel Spa√ü und bin gespannt, was du jetzt f√ºr kreative Websites bauen wirst. Wenn dir dieses Tutorial gefallen hat, teile es doch gern mit deinen Kontakten auf Social Media. üëç üéâ

[^1]: Breakpoints sind festgelegte Punkte, an denen das Layout einer Website angepasst wird, um auf unterschiedlichen Ger√§ten gut auszusehen. Das k√∂nnen zum Beispiel Smartphones, Tablets oder Desktop-Computer sein.
[^2]: Das Elternelement ist das √ºbergeordnete Element, in dem sich das gefloatete Element (folglich auch Kindselement genannt) befindet.
[^3]: Der Viewport ist der sichtbare Bereich des Browsers, in dem die Webseite angezeigt wird. Wenn du die Seite scrollst, bewegt sich der Viewport mit.