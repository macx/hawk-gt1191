---
// Table of Contents for Astro
// Inspired by https://kld.dev/building-table-of-contents/
// and https://kld.dev/toc-animation/

import TableOfContentsHeading from './TableOfContentsHeading.astro'
import Button from './Button.astro'

const { headings } = Astro.props
const toc = buildToc(headings)

type Heading = {
  depth: number
  text: string
  slug: string
  subheadings?: Array<Heading>
}

function buildToc(headings: Array<Heading>) {
  const toc: Array<Heading> = []
  const parentHeadings: Map<number, Heading> = new Map()

  if (!headings) {
    return toc
  }

  headings.forEach((h: Heading) => {
    const heading = { ...h, subheadings: [] }
    parentHeadings.set(heading.depth, heading)

    // Change 2 to 1 if the markdown includes a <h1>
    if (heading.depth === 2 && heading.slug !== 'footnote-label') {
      toc.push(heading)
    } else {
      const parentHeading: Heading | undefined = parentHeadings.get(
        heading.depth - 1
      )

      if (parentHeading) {
        parentHeading.subheadings?.push(heading)
      }
    }
  })

  return toc
}
---

{
  toc?.length > 0 && (
    <aside>
      <nav class='toc'>
        <div class='toc-title'>
          <h2 class='upper-title'>Inhalt</h2>

          <Button
            type='button'
            label='Inhalt anzeigen'
            small={true}
            listener='toggle-toc'
          />
        </div>

        <ul class='toc-list'>
          {toc.map((heading, index) => (
            <TableOfContentsHeading heading={heading} index={index} />
          ))}
        </ul>

        <svg class='toc-progress' xmlns='http://www.w3.org/2000/svg'>
          <path
            class='toc-marker-background'
            fill='none'
            stroke='currentColor'
            stroke-linecap='round'
            stroke-width='2'
            stroke-linejoin='round'
          />
          <circle
            class='toc-marker-start-background'
            cx='5'
            cy='45'
            r='4'
            fill='currentColor'
          />
          <line
            class='toc-marker-end-background'
            x1='1'
            y1='100%'
            x2='9'
            y2='100%'
            stroke='currentColor'
            stroke-width='3'
          />
          <circle
            class='toc-marker-start'
            cx='5'
            cy='45'
            r='4'
            fill='currentColor'
          />
          <path
            class='toc-marker'
            fill='none'
            stroke='currentColor'
            stroke-linecap='round'
            stroke-width='2'
            stroke-dashoffset='2'
            stroke-linejoin='round'
          />
          <line
            class='toc-marker-end'
            x1='1'
            y1='100%'
            x2='9'
            y2='100%'
            stroke='currentColor'
            stroke-width='3'
          />
        </svg>
      </nav>
    </aside>
  )
}

<script>
  const toc: HTMLElement = document.querySelector('.toc')!

  if (toc) {
    const links: NodeListOf<HTMLAnchorElement> = toc.querySelectorAll('a')
    const sections = Array.from(links)
      .map((link) => {
        const href = link.getAttribute('href')
        return href ? document.getElementById(href.substring(1)) : null
      })
      .filter((section): section is HTMLElement => !!section)

    if (sections.length > 1 && links.length > 1) {
      const HIGHLIGHT_CLASS: string = 'highlight'

      const MarkerPaddingInlineLeft = 3
      let markerOffset = 0

      // Create some WeakMaps to store the distances to the top and
      // bottom of each link
      const linkStarts = new WeakMap()
      const linkEnds = new WeakMap()
      let lastActiveLink: HTMLAnchorElement | null = null

      enableToggleButton()
      addIntersectionObserver()
      addResizeObserver()

      function enableToggleButton() {
        const tocList = toc.querySelector('.toc-list') as HTMLUListElement
        const toggleBtn = toc.querySelector(
          '[data-listener="toggle-toc"]'
        ) as HTMLButtonElement
        if (!toggleBtn) return

        tocList.classList.add('hidden-l')

        toggleBtn.addEventListener('click', () => {
          const isOpen = tocList.classList.toggle('hidden-l')

          toggleBtn.textContent = isOpen
            ? 'Inhalt anzeigen'
            : 'Inhalt verbergen'
        })
      }

      function addIntersectionObserver() {
        const headingStates = new Map()
        const TOP_OFFSET = 80

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const { target, isIntersecting, boundingClientRect } = entry
              const state = isIntersecting
                ? 'visible'
                : boundingClientRect.top < TOP_OFFSET
                  ? 'above'
                  : 'below'
              headingStates.set(target, state)
            })

            let activeHeading: HTMLElement | null = null
            // Find the last heading that is above or visible
            sections.forEach((section) => {
              const state = headingStates.get(section)
              if (state === 'above' || state === 'visible') {
                activeHeading = section
              }
            })

            if (!activeHeading && sections.length > 0) {
              activeHeading = sections[0]
            }

            const activeLinks = new Set<HTMLElement>()
            if (activeHeading) {
              const heading = activeHeading as HTMLElement
              const link = toc.querySelector(`a[href="#${heading.id}"]`)
              if (link) {
                activeLinks.add(link as HTMLElement)

                // Check if it's the first child in a nested list
                const listItem = link.closest('li')
                const parentList = listItem?.parentElement
                if (
                  listItem &&
                  parentList &&
                  parentList.tagName === 'UL' &&
                  !parentList.classList.contains('toc-list')
                ) {
                  if (parentList.firstElementChild === listItem) {
                    const parentListItem = parentList.closest('li')
                    const parentLink = parentListItem?.querySelector('a')
                    if (parentLink) {
                      const parentHref = parentLink.getAttribute('href')
                      const parentSection = parentHref
                        ? document.getElementById(parentHref.substring(1))
                        : null
                      if (
                        parentSection &&
                        headingStates.get(parentSection) === 'visible'
                      ) {
                        activeLinks.add(parentLink as HTMLElement)
                      }
                    }
                  }
                }
              }
            }

            links.forEach((link) => {
              if (activeLinks.has(link)) {
                link.classList.add(HIGHLIGHT_CLASS)
              } else {
                link.classList.remove(HIGHLIGHT_CLASS)
              }
            })

            updatePath()
          },
          { rootMargin: '-80px 0px -66% 0px' }
        )

        // Observe all sections/headlines
        sections.forEach((section) => {
          observer.observe(section)
        })
      }

      function addResizeObserver() {
        const observer = new ResizeObserver(() => {
          drawPath()
          updatePath()
        })

        observer.observe(toc)
      }

      function drawPath() {
        const path = toc.querySelector('.toc-marker') as SVGPathElement
        const pathBackground = toc.querySelector(
          '.toc-marker-background'
        ) as SVGPathElement
        const markerStartBackground = toc.querySelector(
          '.toc-marker-start-background'
        ) as SVGCircleElement
        const markerStart = toc.querySelector(
          '.toc-marker-start'
        ) as SVGCircleElement

        if (!links.length) return

        // Start with an empty array of path data values (joinded with sapces later)
        let pathData: string[] = []
        let left = 0 // The last x position / indendation

        // Iterate over each link to build up the pathData
        links.forEach((link, i) => {
          let x = link.offsetLeft
          let y = link.offsetTop
          let height = link.offsetHeight
          markerOffset = x

          if (i === 0) {
            // The top of the first link starts at 0px along the path.
            linkStarts.set(link, 0)

            y = y + MarkerPaddingInlineLeft
            height = height - MarkerPaddingInlineLeft - 2

            if (markerStartBackground) {
              markerStartBackground.setAttribute('cx', x.toString())
              markerStartBackground.setAttribute('cy', y.toString())
            }
            if (markerStart) {
              markerStart.setAttribute('cx', x.toString())
              markerStart.setAttribute('cy', y.toString())
            }

            // Like drawing with a pen...
            // 'M'ove to the top left of the first link
            pathData.push('M', x.toString(), (y + 4).toString())
          } else {
            // If the current link is indented differently than the last,
            // then come down to the current link's top before moving
            // left or right. This ensures we get 90-degrees angle at the
            // corners.
            if (left !== x) {
              const r = 10
              const radius = Math.min(r, Math.abs(x - left) / 2)
              const xDir = x > left ? 1 : -1

              pathData.push('L', left.toString(), (y - radius).toString())
              pathData.push(
                'Q',
                left.toString(),
                y.toString(),
                (left + xDir * radius).toString(),
                y.toString()
              )
              pathData.push('L', (x - xDir * radius).toString(), y.toString())
              pathData.push(
                'Q',
                x.toString(),
                y.toString(),
                x.toString(),
                (y + radius).toString()
              )
            } else {
              pathData.push('L', x.toString(), y.toString())
            }

            // Apply the current path data to the path element
            const d = pathData.join(' ')
            path.setAttribute('d', d)
            pathBackground?.setAttribute('d', d)

            // Get the total length of the path now that it extends
            // to the top of this link, and store it in our linkStarts
            // WeakMap.
            linkStarts.set(link, path.getTotalLength())
          }

          // Calculate where the vertical line should end for this link
          let endY = y + height
          if (i < links.length - 1) {
            const nextLink = links[i + 1]
            const nextX = nextLink.offsetLeft
            const nextY = nextLink.offsetTop

            if (nextX !== x) {
              const r = 10
              const radius = Math.min(r, Math.abs(nextX - x) / 2)
              if (nextY - radius < endY) {
                endY = nextY - radius
              }
            }
          }

          // Draw a line to the bottom left of the current link (or capped end)
          pathData.push('L', x.toString(), endY.toString())

          // Save the current link's x position to compare with the next
          // link
          left = x

          // Apply the current path data to the path element again
          const d = pathData.join(' ')
          path.setAttribute('d', d)
          pathBackground?.setAttribute('d', d)

          // Get the length of the path that now extends to the
          // bottom of this link, and store it in our linkEnds WeakMap.
          linkEnds.set(link, path.getTotalLength())
        })
      }

      function updatePath() {
        const path = toc.querySelector('.toc-marker') as SVGPathElement
        if (!path) return

        const markerStart = toc.querySelector(
          '.toc-marker-start'
        ) as SVGCircleElement
        const markerEnd = toc.querySelector('.toc-marker-end') as SVGLineElement
        const markerEndBackground = toc.querySelector(
          '.toc-marker-end-background'
        ) as SVGLineElement

        const pathLength = path.getTotalLength()
        const activeLinks = toc.querySelectorAll(`a.${HIGHLIGHT_CLASS}`)
        const lastLink = links[links.length - 1]

        let linkStart = pathLength
        let linkEnd = 0
        let duration = '250ms'

        if (activeLinks.length > 0) {
          const activeLink = activeLinks[0] as HTMLAnchorElement
          if (lastActiveLink && activeLink !== lastActiveLink) {
            if (activeLink.offsetLeft !== lastActiveLink.offsetLeft) {
              duration = '600ms'
            }
          }
          lastActiveLink = activeLink
        }

        path.style.transitionDuration = duration
        markerStart.style.transitionDuration = duration
        markerEnd.style.transitionDuration = duration

        if (activeLinks.length > 0) {
          const firstActive = activeLinks[0] as HTMLAnchorElement
          const lastActive = activeLinks[
            activeLinks.length - 1
          ] as HTMLAnchorElement

          linkStart = linkStarts.get(firstActive)
          linkEnd = linkEnds.get(lastActive)

          const index = Array.from(links).indexOf(lastActive)
          if (index >= 0 && index < links.length - 1) {
            const nextLink = links[index + 1]
            if (lastActive.offsetLeft !== nextLink.offsetLeft) {
              linkEnd += 12
            }
          }

          const firstIndex = Array.from(links).indexOf(firstActive)
          if (firstIndex > 0) {
            const prevLink = links[firstIndex - 1]
            if (firstActive.offsetLeft !== prevLink.offsetLeft) {
              linkStart -= 12
            }
          }
        }

        // If there are no active links, hide the path
        const wasHidden = path.style.display === 'none'
        path.style.display = activeLinks.length ? 'inline' : 'none'

        const isStartVisible = links[0].classList.contains(HIGHLIGHT_CLASS)
        const isEndVisible = lastLink.classList.contains(HIGHLIGHT_CLASS)

        markerStart.style.opacity = isStartVisible ? '1' : '0'
        markerStart.style.transitionDelay =
          isStartVisible && !wasHidden ? duration : '0s'

        markerEnd.style.opacity = isEndVisible ? '1' : '0'
        markerEnd.style.transitionDelay = isEndVisible ? duration : '0s'

        const lastLinkEndY = lastLink.offsetTop + lastLink.offsetHeight

        markerEnd?.setAttribute('y1', lastLinkEndY.toString())
        markerEnd?.setAttribute('y2', lastLinkEndY.toString())

        markerEndBackground?.setAttribute('y1', lastLinkEndY.toString())
        markerEndBackground?.setAttribute('y2', lastLinkEndY.toString())

        markerEnd?.setAttribute('x1', (markerOffset - 3.5).toString())
        markerEnd?.setAttribute('x2', (markerOffset + 3.5).toString())

        markerEndBackground?.setAttribute('x1', (markerOffset - 3.5).toString())
        markerEndBackground?.setAttribute('x2', (markerOffset + 3.5).toString())

        // FINALLY, do the thing!
        path.setAttribute(
          'stroke-dasharray',
          `1 ${linkStart} ${linkEnd - linkStart} ${pathLength}`
        )
      }
    }
  }
</script>

<style is:global>
  .toc {
    @media screen and (width >= 57.5em) {
      position: sticky;
      inset-block-start: calc(var(--header-height) + var(--sp-content));
      padding-inline-start: 2px;

      overflow-y: auto;
      max-block-size: calc(100dvh - var(--header-height) - var(--sp-l));
      overscroll-behavior: contain;

      & .button {
        display: none !important;
      }
    }
  }

  .toc-title {
    @media screen and (width < 57.5em) {
      & h2 {
        display: none;
      }
    }
  }

  .toc-list {
    margin-block: var(--sp) 0;
    padding-inline-start: 0;
    transition: max-height var(--transition-navi);

    & > li {
      list-style: none;

      & > a {
        font-weight: var(--fw-bold);
      }
    }

    & a {
      display: flex;
      color: var(--clr-text);
      text-decoration: none;
      transition: color 250ms ease;

      &:hover,
      &:focus {
        color: var(--clr-primary);
      }
    }

    & :where(ul ul) {
      padding-inline-start: 0;

      & li {
        list-style: none;
      }
    }

    @media screen and (width < 57.5em) {
      &.hidden-l {
        max-height: 0;
        overflow: hidden;
        margin-block: 0;
      }

      & > li {
        margin-block-end: var(--sp-xs);

        & + li {
          padding-block-start: var(--sp-xs);
          border-block-start: 1px solid var(--clr-line);
        }

        &:has(ul) {
          & > a::after {
            content: ':';
          }
        }
      }

      & :where(ul ul) {
        display: flex;
        column-gap: 1ch;
        flex-wrap: wrap;

        & li:not(:last-child) {
          & a::after {
            content: ',';
          }
        }
      }
    }

    @media screen and (width >= 57.5em) {
      & li {
        padding-inline-start: 3px;
      }

      & a {
        padding-block: 0.5em;
        padding-inline: var(--sp) var(--sp-s);

        &.highlight {
          color: var(--clr-primary);
        }
      }

      & :where(ul ul) {
        --level: var(--level, 1);

        padding-inline-start: var(--sp);
      }
    }
  }

  .toc-progress {
    position: absolute;
    inset-block-start: 0;
    inset-inline-start: 0;
    block-size: 100%;
    inline-size: 100%;
    user-select: none;
    pointer-events: none;
    color: var(--clr-primary);

    @media screen and (width < 57.5em) {
      display: none;
    }
  }

  .toc-marker-background,
  .toc-marker-start-background {
    stroke: var(--clr-line);
    stroke-width: 2;
    opacity: 1;
  }

  .toc-marker-end-background {
    stroke: var(--clr-line);
    stroke-width: 3;
    opacity: 1;
  }

  .toc-marker-start-background {
    fill: none;
  }

  .toc-marker-start {
    fill: none;
    stroke: var(--clr-primary);
    stroke-width: 2;
    stroke-dasharray: 0;
    transition:
      stroke-dasharray 250ms ease,
      opacity 500ms ease;
    opacity: 0;
  }

  .toc-marker {
    transition: stroke-dasharray 250ms ease;
    stroke-width: 2;
  }

  .toc-marker-end {
    transition:
      stroke-dasharray 250ms ease,
      opacity 500ms ease;
    transform: translateY(-1px);
    opacity: 0;
    stroke-width: 3;
  }
</style>
